{"componentChunkName":"component---src-templates-blog-post-js","path":"/leetcode-971/","result":{"data":{"site":{"siteMetadata":{"title":"Canhua's Blog"}},"markdownRemark":{"id":"b8154f00-42ca-5863-bdd7-bf4ca662f467","excerpt":"971. Flip Binary Tree To Match Preorder Traversal use stack JavaScript C++ DFS JavaScript","html":"<p><a href=\"https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal/\">971. Flip Binary Tree To Match Preorder Traversal</a></p>\n<h2>use stack</h2>\n<ul>\n<li>JavaScript</li>\n</ul>\n<pre><code class=\"language-js\">/**\r\n * @param {TreeNode} root\r\n * @param {number[]} voyage\r\n * @return {number[]}\r\n */\r\nvar flipMatchVoyage = function(root, voyage) {\r\n    const flipped = [];\r\n    const nodes = [];\r\n    \r\n    let index = -1;\r\n    nodes.push(root);\r\n    \r\n    while (nodes.length > 0) {\r\n        const node = nodes.pop();\r\n        index++;\r\n        if (node.val !== voyage[index]) {\r\n            return [-1];\r\n        }\r\n        if (node.left &#x26;&#x26; node.left.val !== voyage[index+1]) {\r\n            // swap\r\n            flipped.push(node.val);\r\n            node.left &#x26;&#x26; nodes.push(node.left);\r\n            node.right &#x26;&#x26; nodes.push(node.right);\r\n        } else {\r\n            node.right &#x26;&#x26; nodes.push(node.right);\r\n            node.left &#x26;&#x26; nodes.push(node.left);\r\n        }\r\n    }\r\n    \r\n    return flipped;\r\n};\r\n\n</code></pre>\n<ul>\n<li>C++</li>\n</ul>\n<pre><code class=\"language-c++\">class Solution {\r\n  \r\npublic:\r\n    vector&#x3C;int> flipMatchVoyage(TreeNode* root, vector&#x3C;int>&#x26; voyage) {\r\n        vector&#x3C;int> flipped;\r\n        if (root)\r\n        {\r\n            int index = -1;\r\n            stack&#x3C;TreeNode*> nodes;\r\n            nodes.push(root);\r\n            while (!nodes.empty()) {\r\n                auto node = nodes.top();\r\n                nodes.pop();\r\n                index++;\r\n                if (voyage[index] != node->val) {\r\n                    return {-1};\r\n                }\r\n                \r\n                if (node->left &#x26;&#x26; node->left->val != voyage[index+1]) {\r\n                    flipped.push_back(node->val);\r\n                    std::swap(node->left, node->right);\r\n                }\r\n                \r\n                if (node->right) {\r\n                    nodes.push(node->right);\r\n                }\r\n                if (node->left) {\r\n                    nodes.push(node->left);\r\n                }\r\n            }\r\n        }\r\n        \r\n        return flipped;\r\n    }\r\n};\n</code></pre>\n<h2>DFS</h2>\n<ul>\n<li>JavaScript</li>\n</ul>\n<pre><code class=\"language-js\">var flipMatchVoyage = function(root, voyage) {\r\n    let index = 0;\r\n    const flipped = [];\r\n\r\n    const dfs = (node) => {\r\n        if (!node) return true;\r\n        \r\n        if (node.val !== voyage[index++]) {\r\n            return false;\r\n        }\r\n        \r\n        if (node.left &#x26;&#x26; node.left.val !== voyage[index]) {\r\n            flipped.push(node.val);\r\n            return dfs(node.right) &#x26;&#x26; dfs(node.left);\r\n        } else {\r\n            return dfs(node.left) &#x26;&#x26; dfs(node.right);\r\n        }\r\n    }\r\n    \r\n    if (dfs(root)) {\r\n        return flipped;\r\n    } else {\r\n        return [-1];\r\n    }\r\n};\n</code></pre>","frontmatter":{"title":"LeetCode 971 - Flip Binary Tree To Match Preorder Traversal","date":"March 16, 2022","description":"C++ and JavaScript solution for Flip Binary Tree To Match Preorder Traversal"}},"previous":{"fields":{"slug":"/js-import-file/"},"frontmatter":{"title":"ES6 import"}},"next":{"fields":{"slug":"/algo/"},"frontmatter":{"title":"Trie, Heap and Binary Index Tree"}}},"pageContext":{"id":"b8154f00-42ca-5863-bdd7-bf4ca662f467","previousPostId":"24d8161a-00c2-5663-bdeb-4b89a9a018f4","nextPostId":"a22ea0a0-13fb-592a-8e62-f10049d1d758"}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}